import sys
import select
import curses
from . import bagl
from .display import Display, MODELS
import time
wait_time = 0.01

BUTTON_LEFT  = 1
BUTTON_RIGHT = 2

_TEXT_ = "\033[36;40m"
_BORDER_ = "\033[30;1;40m"
_RESET_COLOR = "\033[0m"

M = [0]*16
M[0b0000] = ' '
M[0b0001] = '\u2598'
M[0b0010] = '\u259D'
M[0b0011] = '\u2580'
M[0b0100] = '\u2596'
M[0b0101] = '\u258C'
M[0b0110] = '\u259E'
M[0b0111] = '\u259B'
M[0b1000] = '\u2597'
M[0b1001] = '\u259A'
M[0b1010] = '\u2590'
M[0b1011] = '\u259C'
M[0b1100] = '\u2584'
M[0b1101] = '\u2599'
M[0b1110] = '\u259F'
M[0b1111] = '\u2588'

# a b
# c d
def map_pix(a,b,c,d):
    return M[d<<3 | c<<2 | b<<1 | a]

class TextWidget:
    def __init__(self, parent, model):
        self.pixels = {}
        self.model = model
        self.width = parent.width
        self.height = parent.height
        self.previous_screen = 0

        self.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.start_color()
        curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_WHITE)
        self.stdscr.nodelay(1)    # returns -1 if nothing
        self.stdscr.clear()
        self.stdscr.keypad(1)   # interpret escape sequences generated by keypad and function keys

    def _redraw(self):
        p = self.pixels
        f = lambda x,y:p.get((x,y),0)

        self.stdscr.clear()
        for i in range(0,self.height-2, 2):
            line = []
            for j in range(0, self.width-2,2):
                line.append(map_pix(f(j,i), f(j+1,i),f(j,i+1), f(j+1,i+1)))

            self.stdscr.addstr(1 + i//2, 0, ' ', curses.color_pair(2))
            self.stdscr.addstr(1 + i//2, 1, ''.join(line), curses.color_pair(1))
            self.stdscr.addstr(1 + i//2, self.width//2 + 1, ' ', curses.color_pair(2))

        self.stdscr.addstr(0, 0, ' '*(self.width//2 + 2), curses.color_pair(2))
        self.stdscr.addstr(self.height//2, 0, ' '*(self.width//2 + 2), curses.color_pair(2))
        self.stdscr.refresh()

    def draw_point(self, x, y, color):
        self.pixels[(x, y)] = int(color!=0)

class TextScreen(Display):
    def __init__(self, apdu, seph, button_tcp, model, keymap):
        self.apdu = apdu
        self.seph = seph
        self.model = model
        self.notifiers = {}

        self.width, self.height = MODELS[model].screen_size

        self.m = TextWidget(self, model)
        self.bagl = bagl.Bagl(self.m, self.width, self.height)

        self._init_notifiers([ apdu, seph ])
        if button_tcp:
            self.add_notifier(button_tcp)

        if keymap is not None:
            self.ARROW_KEYS = list(map(ord, keymap))
        else:
            self.ARROW_KEYS = [curses.KEY_LEFT, curses.KEY_RIGHT, curses.KEY_DOWN]

        self.key2btn = { 
                            self.ARROW_KEYS[0]:BUTTON_LEFT,
                            self.ARROW_KEYS[1]:BUTTON_RIGHT,
                            self.ARROW_KEYS[2]:BUTTON_LEFT | BUTTON_RIGHT,
                        }

    def display_status(self, data):
        self.bagl.display_status(data)

    def screen_update(self):
        self.m._redraw()

    def _init_notifiers(self, classes):
        for klass in classes:
            self.add_notifier(klass)

    def forward_to_app(self, packet):
        self.seph.to_app(packet)

    def forward_to_apdu_client(self, packet):
        self.apdu.forward_to_client(packet)

    def add_notifier(self, klass):
        assert klass.s.fileno() not in self.notifiers
        self.notifiers[klass.s.fileno()] = klass

    def remove_notifier(self, fd):
        n = self.notifiers.pop(fd)
        del n

    def get_keypress(self):
        key = self.m.stdscr.getch()
        if key == -1:
            return True
        elif key in self.ARROW_KEYS:
            self.seph.handle_button(self.key2btn[key], 1)
            time.sleep(wait_time)
            self.seph.handle_button(self.key2btn[key], 0)
            return True
        elif key == ord('q'):
            return False
        else:
            return True

    def run(self):
        while True:
            rlist = list(self.notifiers.keys())
            if not rlist:
                break
            
            rlist += [ sys.stdin ]
            rlist, _, _ = select.select(rlist, [], [])
            if sys.stdin in rlist:
                rlist.remove(sys.stdin)
                if not self.get_keypress():
                    break
            for fd in rlist:
                self.notifiers[fd].can_read(fd, self)

        curses.nocbreak()
        curses.echo()
        curses.endwin()

def display(apdu, seph, button_tcp=None, model='nanos', keymap=None, **_):
    display = TextScreen(apdu, seph, button_tcp, model, keymap)
    display.run()
