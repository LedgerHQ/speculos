/**
 * @file cx_bls_g2.c
 * @brief BLS12-381 G2 operations.
 *        This file is based on BLST API and implements the missing
 *        curve operations on G2.
 * @date 2023-05-09
 *
 * @copyright Copyright (c) 2023
 *
 */

#include "cx_bls.h"
#include "cx_utils.h"
#include <blst.h>
#include <blst_aux.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>

static uint8_t SSWU_ELLP_Z[2][48] = {
  { 0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x9a, 0x4b, 0x1b, 0xa7, 0xb6,
    0x43, 0x4b, 0xac, 0xd7, 0x64, 0x77, 0x4b, 0x84, 0xf3, 0x85, 0x12, 0xbf,
    0x67, 0x30, 0xd2, 0xa0, 0xf6, 0xb0, 0xf6, 0x24, 0x1e, 0xab, 0xff, 0xfe,
    0xb1, 0x53, 0xff, 0xff, 0xb9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xa9 },
  { 0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x9a, 0x4b, 0x1b, 0xa7, 0xb6,
    0x43, 0x4b, 0xac, 0xd7, 0x64, 0x77, 0x4b, 0x84, 0xf3, 0x85, 0x12, 0xbf,
    0x67, 0x30, 0xd2, 0xa0, 0xf6, 0xb0, 0xf6, 0x24, 0x1e, 0xab, 0xff, 0xfe,
    0xb1, 0x53, 0xff, 0xff, 0xb9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xaa, 0xaa }
};

static uint8_t SSWU_ELLP_B[2][48] = {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf4 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf4 }
};

static uint8_t SSWU_ELLP_A[2][48] = {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0 }
};

// constant term = degree-1 coefficient
static uint8_t ISO3_K10[48] = {
  0x05, 0xc7, 0x59, 0x50, 0x7e, 0x8e, 0x33, 0x3e, 0xbb, 0x5b, 0x7a, 0x9a,
  0x47, 0xd7, 0xed, 0x85, 0x32, 0xc5, 0x2d, 0x39, 0xfd, 0x3a, 0x04, 0x2a,
  0x88, 0xb5, 0x84, 0x23, 0xc5, 0x0a, 0xe1, 0x5d, 0x5c, 0x26, 0x38, 0xe3,
  0x43, 0xd9, 0xc7, 0x1c, 0x62, 0x38, 0xaa, 0xaa, 0xaa, 0xaa, 0x97, 0xd6
};

// constant term = 0
static uint8_t ISO3_K11_1[48] = {
  0x11, 0x56, 0x0b, 0xf1, 0x7b, 0xaa, 0x99, 0xbc, 0x32, 0x12, 0x6f, 0xce,
  0xd7, 0x87, 0xc8, 0x8f, 0x98, 0x4f, 0x87, 0xad, 0xf7, 0xae, 0x0c, 0x7f,
  0x9a, 0x20, 0x8c, 0x6b, 0x4f, 0x20, 0xa4, 0x18, 0x14, 0x72, 0xaa, 0xa9,
  0xcb, 0x8d, 0x55, 0x55, 0x26, 0xa9, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x1a
};

static uint8_t ISO3_K12[2][48] = {
  { 0x11, 0x56, 0x0b, 0xf1, 0x7b, 0xaa, 0x99, 0xbc, 0x32, 0x12, 0x6f, 0xce,
    0xd7, 0x87, 0xc8, 0x8f, 0x98, 0x4f, 0x87, 0xad, 0xf7, 0xae, 0x0c, 0x7f,
    0x9a, 0x20, 0x8c, 0x6b, 0x4f, 0x20, 0xa4, 0x18, 0x14, 0x72, 0xaa, 0xa9,
    0xcb, 0x8d, 0x55, 0x55, 0x26, 0xa9, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x1e },
  { 0x08, 0xab, 0x05, 0xf8, 0xbd, 0xd5, 0x4c, 0xde, 0x19, 0x09, 0x37, 0xe7,
    0x6b, 0xc3, 0xe4, 0x47, 0xcc, 0x27, 0xc3, 0xd6, 0xfb, 0xd7, 0x06, 0x3f,
    0xcd, 0x10, 0x46, 0x35, 0xa7, 0x90, 0x52, 0x0c, 0x0a, 0x39, 0x55, 0x54,
    0xe5, 0xc6, 0xaa, 0xaa, 0x93, 0x54, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x8d }
};

// degree-1 coefficient = 0
static uint8_t ISO3_K13_0[48] = {
  0x17, 0x1d, 0x65, 0x41, 0xfa, 0x38, 0xcc, 0xfa, 0xed, 0x6d, 0xea, 0x69,
  0x1f, 0x5f, 0xb6, 0x14, 0xcb, 0x14, 0xb4, 0xe7, 0xf4, 0xe8, 0x10, 0xaa,
  0x22, 0xd6, 0x10, 0x8f, 0x14, 0x2b, 0x85, 0x75, 0x70, 0x98, 0xe3, 0x8d,
  0x0f, 0x67, 0x1c, 0x71, 0x88, 0xe2, 0xaa, 0xaa, 0xaa, 0xaa, 0x5e, 0xd1
};

// constant term = 0
static uint8_t ISO3_K20_1[48] = {
  0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x9a, 0x4b, 0x1b, 0xa7, 0xb6,
  0x43, 0x4b, 0xac, 0xd7, 0x64, 0x77, 0x4b, 0x84, 0xf3, 0x85, 0x12, 0xbf,
  0x67, 0x30, 0xd2, 0xa0, 0xf6, 0xb0, 0xf6, 0x24, 0x1e, 0xab, 0xff, 0xfe,
  0xb1, 0x53, 0xff, 0xff, 0xb9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xaa, 0x63
};

static uint8_t ISO3_K21[2][48] = {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c },
  { 0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x9a, 0x4b, 0x1b, 0xa7, 0xb6,
    0x43, 0x4b, 0xac, 0xd7, 0x64, 0x77, 0x4b, 0x84, 0xf3, 0x85, 0x12, 0xbf,
    0x67, 0x30, 0xd2, 0xa0, 0xf6, 0xb0, 0xf6, 0x24, 0x1e, 0xab, 0xff, 0xfe,
    0xb1, 0x53, 0xff, 0xff, 0xb9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xaa, 0x9f }
};

// constant term = degree-1 coefficient
static uint8_t ISO3_K30[48] = {
  0x15, 0x30, 0x47, 0x7c, 0x7a, 0xb4, 0x11, 0x3b, 0x59, 0xa4, 0xc1, 0x8b,
  0x07, 0x6d, 0x11, 0x93, 0x0f, 0x7d, 0xa5, 0xd4, 0xa0, 0x7f, 0x64, 0x9b,
  0xf5, 0x44, 0x39, 0xd8, 0x7d, 0x27, 0xe5, 0x00, 0xfc, 0x8c, 0x25, 0xeb,
  0xf8, 0xc9, 0x2f, 0x68, 0x12, 0xcf, 0xc7, 0x1c, 0x71, 0xc6, 0xd7, 0x06
};

// constant term = 0
static uint8_t ISO3_K31_1[48] = {
  0x05, 0xc7, 0x59, 0x50, 0x7e, 0x8e, 0x33, 0x3e, 0xbb, 0x5b, 0x7a, 0x9a,
  0x47, 0xd7, 0xed, 0x85, 0x32, 0xc5, 0x2d, 0x39, 0xfd, 0x3a, 0x04, 0x2a,
  0x88, 0xb5, 0x84, 0x23, 0xc5, 0x0a, 0xe1, 0x5d, 0x5c, 0x26, 0x38, 0xe3,
  0x43, 0xd9, 0xc7, 0x1c, 0x62, 0x38, 0xaa, 0xaa, 0xaa, 0xaa, 0x97, 0xbe
};

static uint8_t ISO3_K32[2][48] = {
  { 0x11, 0x56, 0x0b, 0xf1, 0x7b, 0xaa, 0x99, 0xbc, 0x32, 0x12, 0x6f, 0xce,
    0xd7, 0x87, 0xc8, 0x8f, 0x98, 0x4f, 0x87, 0xad, 0xf7, 0xae, 0x0c, 0x7f,
    0x9a, 0x20, 0x8c, 0x6b, 0x4f, 0x20, 0xa4, 0x18, 0x14, 0x72, 0xaa, 0xa9,
    0xcb, 0x8d, 0x55, 0x55, 0x26, 0xa9, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x1c },
  { 0x08, 0xab, 0x05, 0xf8, 0xbd, 0xd5, 0x4c, 0xde, 0x19, 0x09, 0x37, 0xe7,
    0x6b, 0xc3, 0xe4, 0x47, 0xcc, 0x27, 0xc3, 0xd6, 0xfb, 0xd7, 0x06, 0x3f,
    0xcd, 0x10, 0x46, 0x35, 0xa7, 0x90, 0x52, 0x0c, 0x0a, 0x39, 0x55, 0x54,
    0xe5, 0xc6, 0xaa, 0xaa, 0x93, 0x54, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x8f }
};

// degree-1 coefficient = 0
static uint8_t ISO3_K33_0[48] = {
  0x12, 0x4c, 0x9a, 0xd4, 0x3b, 0x6c, 0xf7, 0x9b, 0xfb, 0xf7, 0x04, 0x3d,
  0xe3, 0x81, 0x1a, 0xd0, 0x76, 0x1b, 0x0f, 0x37, 0xa1, 0xe2, 0x62, 0x86,
  0xb0, 0xe9, 0x77, 0xc6, 0x9a, 0xa2, 0x74, 0x52, 0x4e, 0x79, 0x09, 0x7a,
  0x56, 0xdc, 0x4b, 0xd9, 0xe1, 0xb3, 0x71, 0xc7, 0x1c, 0x71, 0x8b, 0x10
};

// constant term = degree-1 coefficient
static uint8_t ISO3_K40[48] = {
  0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x9a, 0x4b, 0x1b, 0xa7, 0xb6,
  0x43, 0x4b, 0xac, 0xd7, 0x64, 0x77, 0x4b, 0x84, 0xf3, 0x85, 0x12, 0xbf,
  0x67, 0x30, 0xd2, 0xa0, 0xf6, 0xb0, 0xf6, 0x24, 0x1e, 0xab, 0xff, 0xfe,
  0xb1, 0x53, 0xff, 0xff, 0xb9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xa8, 0xfb
};

// constant term = 0
static uint8_t ISO3_K41_1[48] = {
  0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x9a, 0x4b, 0x1b, 0xa7, 0xb6,
  0x43, 0x4b, 0xac, 0xd7, 0x64, 0x77, 0x4b, 0x84, 0xf3, 0x85, 0x12, 0xbf,
  0x67, 0x30, 0xd2, 0xa0, 0xf6, 0xb0, 0xf6, 0x24, 0x1e, 0xab, 0xff, 0xfe,
  0xb1, 0x53, 0xff, 0xff, 0xb9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xa9, 0xd3
};

static uint8_t ISO3_K42[2][48] = {
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12 },
  { 0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x9a, 0x4b, 0x1b, 0xa7, 0xb6,
    0x43, 0x4b, 0xac, 0xd7, 0x64, 0x77, 0x4b, 0x84, 0xf3, 0x85, 0x12, 0xbf,
    0x67, 0x30, 0xd2, 0xa0, 0xf6, 0xb0, 0xf6, 0x24, 0x1e, 0xab, 0xff, 0xfe,
    0xb1, 0x53, 0xff, 0xff, 0xb9, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xaa, 0x99 }
};

static uint8_t FP_ZERO[48] = { 0 };

// 0xd201000000010000 = -c1
static uint8_t CLEAR_C1_NEG[] = {
  0xd2, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00
};

// constant term = 0
static uint8_t PSI_C1_1[] = { 0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x99,
                              0xec, 0x02, 0x40, 0x86, 0x63, 0xd4, 0xde, 0x85,
                              0xaa, 0x0d, 0x85, 0x7d, 0x89, 0x75, 0x9a, 0xd4,
                              0x89, 0x7d, 0x29, 0x65, 0x0f, 0xb8, 0x5f, 0x9b,
                              0x40, 0x94, 0x27, 0xeb, 0x4f, 0x49, 0xff, 0xfd,
                              0x8b, 0xfd, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xad };

static uint8_t PSI_C2[2][48] = {
  { 0x13, 0x52, 0x03, 0xe6, 0x01, 0x80, 0xa6, 0x8e, 0xe2, 0xe9, 0xc4, 0x48,
    0xd7, 0x7a, 0x2c, 0xd9, 0x1c, 0x3d, 0xed, 0xd9, 0x30, 0xb1, 0xcf, 0x60,
    0xef, 0x39, 0x64, 0x89, 0xf6, 0x1e, 0xb4, 0x5e, 0x30, 0x44, 0x66, 0xcf,
    0x3e, 0x67, 0xfa, 0x0a, 0xf1, 0xee, 0x7b, 0x04, 0x12, 0x1b, 0xde, 0xa2 },
  { 0x06, 0xaf, 0x0e, 0x04, 0x37, 0xff, 0x40, 0x0b, 0x68, 0x31, 0xe3, 0x6d,
    0x6b, 0xd1, 0x7f, 0xfe, 0x48, 0x39, 0x5d, 0xab, 0xc2, 0xd3, 0x43, 0x5e,
    0x77, 0xf7, 0x6e, 0x17, 0x00, 0x92, 0x41, 0xc5, 0xee, 0x67, 0x99, 0x2f,
    0x72, 0xec, 0x05, 0xf4, 0xc8, 0x10, 0x84, 0xfb, 0xed, 0xe3, 0xcc, 0x09 }
};

// degree-1 coefficient = 0
static uint8_t PSI2_C1_0[48] = {
  0x1a, 0x01, 0x11, 0xea, 0x39, 0x7f, 0xe6, 0x99, 0xec, 0x02, 0x40, 0x86,
  0x63, 0xd4, 0xde, 0x85, 0xaa, 0x0d, 0x85, 0x7d, 0x89, 0x75, 0x9a, 0xd4,
  0x89, 0x7d, 0x29, 0x65, 0x0f, 0xb8, 0x5f, 0x9b, 0x40, 0x94, 0x27, 0xeb,
  0x4f, 0x49, 0xff, 0xfd, 0x8b, 0xfd, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xac
};

void cx_bls_g2_psi(blst_p2_affine *ret_point, blst_p2_affine *point)
{
  blst_fp2 one, tmp, constant;

  cx_bls_fp2_set_one(&one);
  cx_bls_fp2_frobenius(&tmp, &one);
  blst_fp2_inverse(&one, &tmp);
  cx_bls_fp2_from_bendian(&constant, FP_ZERO, PSI_C1_1);
  cx_bls_fp2_frobenius(&tmp, &point->x);
  blst_fp2_mul(&ret_point->x, &constant, &tmp);
  blst_fp2_mul(&tmp, &ret_point->x, &one);
  cx_bls_fp2_copy(&ret_point->x, &tmp);

  cx_bls_fp2_from_bendian(&constant, PSI_C2[0], PSI_C2[1]);
  cx_bls_fp2_frobenius(&tmp, &point->y);
  blst_fp2_mul(&ret_point->y, &constant, &tmp);
  blst_fp2_mul(&tmp, &ret_point->y, &one);
  cx_bls_fp2_copy(&ret_point->y, &tmp);
}

void cx_bls_g2_psi2(blst_p2_affine *ret_point, blst_p2_affine *point)
{
  blst_fp2 c1;
  cx_bls_fp2_from_bendian(&c1, PSI2_C1_0, FP_ZERO);
  blst_fp2_mul(&ret_point->x, &c1, &point->x);
  blst_fp2_cneg(&ret_point->y, &point->y, true);
}

/* map_to_curve_simple_swu
 * (Appendix F.2
 * https://www.ietf.org/id/draft-irtf-cfrg-hash-to-curve-16.html#straightline-sswu)
 */
void cx_bls_g2_map_to_curve_simple_swu(blst_p2_affine *point, blst_fp2 *u)
{
  blst_fp2 tv1, tv1_tmp;
  blst_fp2 tv2, tv2_tmp;
  blst_fp2 tv3, tv3_tmp;
  blst_fp2 tv4, tv4_tmp;
  blst_fp2 tv5, tv6, tv6_tmp;
  blst_fp2 z, a, b, x, y1, y;
  bool is_zero = false;
  bool is_gx1_square = false;
  bool e1 = false;

  blst_fp2_sqr(&tv1_tmp, u);
  cx_bls_fp2_from_bendian(&z, SSWU_ELLP_Z[0], SSWU_ELLP_Z[1]);
  blst_fp2_mul(&tv1, &z, &tv1_tmp);
  blst_fp2_sqr(&tv2_tmp, &tv1);
  blst_fp2_add(&tv2, &tv2_tmp, &tv1);
  cx_bls_fp2_set_one(&tv1_tmp);
  blst_fp2_add(&tv3_tmp, &tv2, &tv1_tmp);
  cx_bls_fp2_from_bendian(&b, SSWU_ELLP_B[0], SSWU_ELLP_B[1]);
  blst_fp2_mul(&tv3, &b, &tv3_tmp);
  blst_fp2_cneg(&tv2_tmp, &tv2, true);
  is_zero = cx_bls_fp2_is_zero(&tv2);
  cx_bls_fp2_conditional_move(&tv4_tmp, &z, &tv2_tmp, !is_zero);
  cx_bls_fp2_from_bendian(&a, SSWU_ELLP_A[0], SSWU_ELLP_A[1]);
  blst_fp2_mul(&tv4, &a, &tv4_tmp);
  blst_fp2_sqr(&tv2, &tv3);
  blst_fp2_sqr(&tv6, &tv4);
  blst_fp2_mul(&tv5, &a, &tv6);
  blst_fp2_add(&tv2_tmp, &tv2, &tv5);
  blst_fp2_mul(&tv2, &tv2_tmp, &tv3);
  blst_fp2_mul(&tv6_tmp, &tv6, &tv4);
  cx_bls_fp2_copy(&tv6, &tv6_tmp);
  blst_fp2_mul(&tv5, &b, &tv6);
  blst_fp2_add(&tv2_tmp, &tv2, &tv5);
  cx_bls_fp2_copy(&tv2, &tv2_tmp);
  blst_fp2_mul(&x, &tv1, &tv3);
  is_gx1_square = cx_bls_fp2_sqrt_ratio(&y1, &tv2, &tv6);
  blst_fp2_mul(&tv1_tmp, &tv1, u);
  blst_fp2_mul(&point->y, &tv1_tmp, &y1);
  cx_bls_fp2_conditional_move(&point->x, &x, &tv3, is_gx1_square);
  cx_bls_fp2_copy(&x, &point->x);
  cx_bls_fp2_conditional_move(&y, &point->y, &y1, is_gx1_square);
  e1 = (cx_bls_fp2_sgn0(u) == cx_bls_fp2_sgn0(&y));
  blst_fp2_cneg(&tv1_tmp, &y, true);
  cx_bls_fp2_conditional_move(&point->y, &tv1_tmp, &y, e1);
  blst_fp2_inverse(&tv4_tmp, &tv4);
  blst_fp2_mul(&point->x, &x, &tv4_tmp);
}

/* 3-isogeny map
 *  (Appendix E.3
 * https://www.ietf.org/id/draft-irtf-cfrg-hash-to-curve-16.html#appx-iso-bls12381-g2)
 */
void cx_bls_g2_iso_map_3(blst_p2_affine *ret_point, blst_p2_affine *point)
{
  blst_fp2 num, den, term, coeff, x2, x3;
  cx_bls_fp2_from_bendian(&coeff, FP_ZERO, ISO3_K11_1);
  // x * k11
  blst_fp2_mul(&term, &point->x, &coeff);
  cx_bls_fp2_from_bendian(&coeff, ISO3_K10, ISO3_K10);
  blst_fp2_add(&num, &term, &coeff);
  blst_fp2_sqr(&x2, &point->x);
  cx_bls_fp2_from_bendian(&coeff, ISO3_K12[0], ISO3_K12[1]);
  // x^2 * k12
  blst_fp2_mul(&term, &x2, &coeff);
  blst_fp2_add(&ret_point->x, &num, &term);
  blst_fp2_mul(&x3, &point->x, &x2);
  cx_bls_fp2_from_bendian(&coeff, ISO3_K13_0, FP_ZERO);
  // x^3 * k13
  blst_fp2_mul(&term, &x3, &coeff);
  blst_fp2_add(&num, &ret_point->x, &term);

  // x * k21
  cx_bls_fp2_from_bendian(&coeff, ISO3_K21[0], ISO3_K21[1]);
  blst_fp2_mul(&term, &point->x, &coeff);
  cx_bls_fp2_from_bendian(&coeff, FP_ZERO, ISO3_K20_1);
  blst_fp2_add(&den, &term, &coeff);
  // x^2 + k21 * x * k20 *x
  blst_fp2_add(&term, &den, &x2);
  blst_fp2_inverse(&den, &term);
  blst_fp2_mul(&ret_point->x, &num, &den);

  cx_bls_fp2_from_bendian(&coeff, FP_ZERO, ISO3_K31_1);
  // x * k31
  blst_fp2_mul(&term, &point->x, &coeff);
  cx_bls_fp2_from_bendian(&coeff, ISO3_K30, ISO3_K30);
  // x * k31 + k30
  blst_fp2_add(&num, &term, &coeff);
  cx_bls_fp2_from_bendian(&coeff, ISO3_K32[0], ISO3_K32[1]);
  // x^2 * k32
  blst_fp2_mul(&term, &x2, &coeff);
  // x^2 * k32 + x * k31 + k30
  blst_fp2_add(&ret_point->y, &num, &term);
  cx_bls_fp2_from_bendian(&coeff, ISO3_K33_0, FP_ZERO);
  // x^3 * k33
  blst_fp2_mul(&term, &x3, &coeff);
  blst_fp2_add(&num, &ret_point->y, &term);

  cx_bls_fp2_from_bendian(&coeff, FP_ZERO, ISO3_K41_1);
  // x * k41
  blst_fp2_mul(&term, &point->x, &coeff);
  cx_bls_fp2_from_bendian(&coeff, ISO3_K40, ISO3_K40);
  // x * k41 + k40
  blst_fp2_add(&den, &term, &coeff);
  cx_bls_fp2_from_bendian(&coeff, ISO3_K42[0], ISO3_K42[1]);
  // x^2 * k42
  blst_fp2_mul(&term, &x2, &coeff);
  // x^2 * k42 + x * k41 + k40
  blst_fp2_add(&ret_point->y, &den, &term);
  blst_fp2_add(&term, &ret_point->y, &x3);
  // 1/y_den
  blst_fp2_inverse(&den, &term);
  blst_fp2_mul(&term, &num, &den);
  blst_fp2_mul(&ret_point->y, &point->y, &term);
}

/* Clearing cofactor
 *  Appendix G.3
 * https://www.ietf.org/id/draft-irtf-cfrg-hash-to-curve-16.html#appendix-G.3
 */
void cx_bls_g2_clear_cofactor(blst_p2_affine *ret_point, blst_p2_affine *point)
{
  blst_p2 t1, t2, t2_tmp, t3, t3_tmp;
  blst_p2 p2_point;
  blst_p2_affine t2_affine, t3_affine;
  uint8_t c1[8];

  memcpy(c1, CLEAR_C1_NEG, sizeof(CLEAR_C1_NEG));
  be2le(c1, sizeof(c1));

  blst_p2_from_affine(&p2_point, point);
  blst_p2_mult(&t1, &p2_point, c1, sizeof(c1) * 8);
  blst_p2_cneg(&t1, true);
  cx_bls_g2_psi(&t2_affine, point);
  blst_p2_from_affine(&t2, &t2_affine);
  blst_p2_double(&t3, &p2_point);
  blst_p2_to_affine(&t3_affine, &t3);
  cx_bls_g2_psi2(&t2_affine, &t3_affine);
  blst_p2_from_affine(&t3, &t2_affine);
  blst_p2_cneg(&t2, true);
  blst_p2_add(&t3_tmp, &t3, &t2);
  blst_p2_cneg(&t2, true);
  blst_p2_add(&t2_tmp, &t1, &t2);
  blst_p2_mult(&t2, &t2_tmp, c1, sizeof(c1) * 8);
  blst_p2_cneg(&t2, true);
  blst_p2_add(&t3, &t3_tmp, &t2);
  blst_p2_cneg(&t1, true);
  blst_p2_add(&t3_tmp, &t3, &t1);
  blst_p2_cneg(&p2_point, true);
  blst_p2_add(&t2_tmp, &t3_tmp, &p2_point);
  blst_p2_to_affine(ret_point, &t2_tmp);
}

/* hash = (u, v)
 *  Q0 = map_to_curve(u)
 *  Q1 = map_to_curve(v)
 *  R = Q0 + Q1
 *  P = clear_cofactor(R)
 */
void cx_bls_g2_hash_field_to_curve(blst_p2_affine *point, uint8_t *hash,
                                   size_t hash_len)
{
  blst_fp2 u, v;
  blst_p2_affine q0, q1;
  blst_p2 p2_point, p2_q0, p2_q1;

  cx_bls_fp2_from_bendian(&u, hash, hash + (hash_len / 4));
  cx_bls_fp2_from_bendian(&v, hash + (hash_len / 2), hash + 3 * (hash_len / 4));
  cx_bls_g2_map_to_curve_simple_swu(&q0, &u);
  cx_bls_g2_map_to_curve_simple_swu(&q1, &v);
  blst_p2_from_affine(&p2_q0, &q0);
  blst_p2_from_affine(&p2_q1, &q1);
  blst_p2_add(&p2_point, &p2_q0, &p2_q1);
  blst_p2_to_affine(&q0, &p2_point);
  cx_bls_g2_iso_map_3(&q1, &q0);
  cx_bls_g2_clear_cofactor(point, &q1);
}
